<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>RRAM API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>RRAM</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import CommandMap as CM
import PyTerminal as PT


def id (verbal=True):
    &#34;&#34;&#34; **[Low Level]** Get the ID of the RRAM Modules

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The ID of the RRAM Modules. (should be *0x01314520*)

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_PID, verbal)


def lane(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the selected ADC lane

    Args:
        action (str): Could be *set* or *get*
        target (str): Target lane number, from *0*~*7*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The selected lane.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_LANE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_LANE + &#39; &#39; + CM.CM_RRAM_GET, verbal))
    else: PT.unknown([&#39;RRAM&#39;, &#39;lane&#39;, action, target])


def group(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the selected group for the Vector module

    Args:
        action (str): Could be *set* or *get*
        target (str): Target group number, from *0*~*35*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The selected group.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_GROUP + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_GROUP + &#39; &#39; + CM.CM_RRAM_GET, verbal))
    else: PT.unknown([&#39;RRAM&#39;, &#39;group&#39;, action, target])


def module(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the selected RRAM module

    Args:
        action (str): Could be *set* or *get*
        target (str): Target RRAM module number, from *0*~*287*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The selected module.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MODULE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MODULE + &#39; &#39; + CM.CM_RRAM_GET, verbal))
    else: PT.unknown([&#39;RRAM&#39;, &#39;module&#39;, action, target])


def mask(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the RRAM module selection mask register

    Args:
        action (str): Could be *set* or *get*
        target (str): Target RRAM module selection mask, from *0x00000001*~*0xFFFFFFFF*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The current mask.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MASK + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MASK + &#39; &#39; + CM.CM_RRAM_GET, verbal)
    else: PT.unknown([&#39;RRAM&#39;, &#39;mask&#39;, action, target])


def address(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the RRAM module address register

    Args:
        action (str): Could be *set* or *get*
        target (str): Target address, from *0*~*65535*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The current address.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADDRESS + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADDRESS + &#39; &#39; + CM.CM_RRAM_GET, verbal))
    else: PT.unknown([&#39;RRAM&#39;, &#39;address&#39;, action, target])


def read(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure read related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *status*, *enable*, *cycle*, *source*, *counter*, *data*
        target (str): Target number, *0*~*1* for *enable* *source*, *0*~*255* for *cycle*, and *0x1*~*0x1FF* for *data*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str or int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;enable&#39; :        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_ENABLE  + &#39; &#39; + target, verbal)
        elif action_type == &#39;cycle&#39;  :        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_CYCLE   + &#39; &#39; + target, verbal)
        elif action_type == &#39;source&#39; :        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_SOURCE  + &#39; &#39; + target, verbal)
        elif action_type == &#39;counter&#39;:        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_COUNTER + &#39; &#39; + target, verbal)
        elif action_type == &#39;data&#39;   :        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_DATA    + &#39; &#39; + target, verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;read&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;enable&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_ENABLE , verbal))
        elif action_type == &#39;status&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_STATUS , verbal))
        elif action_type == &#39;cycle&#39;  : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_CYCLE  , verbal))
        elif action_type == &#39;source&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_SOURCE , verbal))
        elif action_type == &#39;counter&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_COUNTER, verbal))
        elif action_type == &#39;data&#39;   : return     PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_DATA   , verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;read&#39;, action, action_type, target])
    elif action == &#39;toggle&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_TOGGLE, verbal)
    else: PT.unknown([&#39;RRAM&#39;, &#39;read&#39;, action, action_type, target])


def mac(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure mac related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *status*, *result*, *mode*, *resolution*
        target (str): Target number, *0*~*1* for *mode*, *0*~*3* for *resolution*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;mode&#39;      :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_MAC_MODE       + &#39; &#39; + target, verbal)
        elif action_type == &#39;resolution&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_MAC_RESOLUTION + &#39; &#39; + target, verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;mac&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;status&#39;    : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_MAC_STATUS    , verbal))
        elif action_type == &#39;mode&#39;      : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_MAC_MODE      , verbal))
        elif action_type == &#39;resolution&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_MAC_RESOLUTION, verbal))
        elif action_type == &#39;result&#39;    : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_MAC_RESULT    , verbal))
        else: PT.unknown([&#39;RRAM&#39;, &#39;mac&#39;, action, action_type, target])
    else: PT.unknown([&#39;RRAM&#39;, &#39;mac&#39;, action, action_type, target])


def write(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure read related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *status*, *enable*, *cycle*, *mode*
        target (str): Target number, *0*~*1* for *enable* *mode*, *0*~*65535* for *cycle*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.
    Returns:
        int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;enable&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_WRITE_ENABLE + &#39; &#39; + target, verbal)
        elif action_type == &#39;cycle&#39; :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_WRITE_CYCLE  + &#39; &#39; + target, verbal)
        elif action_type == &#39;mode&#39;  :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_WRITE_MODE   + &#39; &#39; + target, verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;write&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;enable&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_WRITE_ENABLE, verbal))
        elif action_type == &#39;status&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_WRITE_STATUS, verbal))
        elif action_type == &#39;cycle&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_WRITE_CYCLE , verbal))
        elif action_type == &#39;mode&#39;  : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_WRITE_MODE  , verbal))
        else: PT.unknown([&#39;RRAM&#39;, &#39;write&#39;, action, action_type, target])
    elif action == &#39;trigger&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_TRIGGER, verbal)
    else: PT.unknown([&#39;RRAM&#39;, &#39;write&#39;, action, action_type, target])


def adc(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure ADC related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *raw*, *step*, *offset*, *comp*, *hbias*, *cal*
        target (str): Target number, *0*~*1* for *hbias* *cal*, *0*~*63* for *step* *offset*, *0x0000*~*0x7FFF* for *comp*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str or int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;step&#39;  :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_STEP   + &#39; &#39; + target, verbal)
        elif action_type == &#39;offset&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_OFFSET + &#39; &#39; + target, verbal)
        elif action_type == &#39;comp&#39;  :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_COMP   + &#39; &#39; + target, verbal)
        elif action_type == &#39;hbias&#39; :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_HBIAS  + &#39; &#39; + target, verbal)
        elif action_type == &#39;cal&#39;   :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_CAL    + &#39; &#39; + target, verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;adc&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;raw&#39;   : return     PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_RAW   , verbal)
        elif action_type == &#39;step&#39;  : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_STEP  , verbal))
        elif action_type == &#39;offset&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_OFFSET, verbal))
        elif action_type == &#39;comp&#39;  : return     PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_COMP  , verbal)
        elif action_type == &#39;hbias&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_HBIAS , verbal))
        elif action_type == &#39;cal&#39;   : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_CAL   , verbal))
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;adc&#39;, action, action_type, target])
    else: PT.unknown([&#39;RRAM&#39;, &#39;adc&#39;, action, action_type, target])


def pg(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure power gating related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *disable*
        target (str): Target number, *0*~*1* for *disable*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;disable&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_PG + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_PG_DISABLE + &#39; &#39; + target, verbal)
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;pg&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;disable&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_PG + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_PG_DISABLE, verbal))
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;pg&#39;, action, action_type, target])
    else: PT.unknown([&#39;RRAM&#39;, &#39;pg&#39;, action, action_type, target])


def ecc(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure power gating related settings

    Args:
        action (str): Could be *set*, *get*, *clear*, or *check*
        action_type (str): Could be *enable*
        target (str): Target number, *0*~*1* for *enable*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str or int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;enable&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ECC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ECC_ENABLE + &#39; &#39; + target, verbal)
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;ecc&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;enable&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ECC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ECC_ENABLE, verbal))
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;ecc&#39;, action, action_type, target])
    elif action == &#39;clear&#39;:
               PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ECC + &#39; &#39; + CM.CM_RRAM_CLEAR, verbal)
    elif action == &#39;check&#39;:
        return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ECC + &#39; &#39; + CM.CM_RRAM_CHECK, verbal)
    else: PT.unknown([&#39;RRAM&#39;, &#39;ecc&#39;, action, action_type, target])


def reg_status(verbal=True):
    &#34;&#34;&#34; **[High Level]** Print the register status of the RRAM accelerator

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_REG_STATUS, verbal)


def env_init(verbal=True):
    &#34;&#34;&#34; **[High Level]** Initialize the environment configurations of the RRAM accelerator and the currently selected RRAM modules

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_ENV_INIT, verbal)


def env_status(verbal=True):
    &#34;&#34;&#34; **[High Level]** Print the environment configurations of the RRAM accelerator and the currently selected RRAM modules

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_ENV_STATUS, verbal)


def mod_init(verbal=True):
    &#34;&#34;&#34; **[High Level]** Initialize the module floorplan status

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_MOD_INIT, verbal)


def mod_status(verbal=True):
    &#34;&#34;&#34; **[High Level]** Print the module floorplan status

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_MOD_STATUS, verbal)


def mod_conf(status, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure the current module floorplan status

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    status_dict = {
        &#39;C&#39;: CM.CM_RRAM_API_MOD_STATUS_CLEAN,
        &#39;F&#39;: CM.CM_RRAM_API_MOD_STATUS_FORMED,
        &#39;P&#39;: CM.CM_RRAM_API_MOD_STATUS_PARTIALLY_FORMED,
        &#39;U&#39;: CM.CM_RRAM_API_MOD_STATUS_USED,
        &#39;B&#39;: CM.CM_RRAM_API_MOD_STATUS_BROKEN,
        &#39;A&#39;: CM.CM_RRAM_API_MOD_STATUS_ADC_FATAL,
        &#39;?&#39;: CM.CM_RRAM_API_MOD_STATUS_UNKNOWN,
    }
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_MOD_CONF + &#39; &#39; + str(status_dict[status]), verbal)


def switch(index, verbal=True):
    &#34;&#34;&#34; **[High Level]** Switch to module *index* and configure related things. (ex. ADC, VTGT_BL ... etc)

    Args:
        index (str): Target RRAM Module, from *0* ~ *287*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SWITCH + &#39; &#39; + index, verbal)


def conf_form(AVDD_WR, AVDD_WL, cycle, times, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure FORM operation

    Args:
        AVDD_WR (str): AVDD_WR voltage for FORM
        AVDD_WL (str): AVDD_WL voltage for FORM
        cycle (str): number of clock cycles per pulse for FORM
        times (str): number of pulses for FORM
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_FORM + &#39; &#39; + AVDD_WR + &#39; &#39; + AVDD_WL + &#39; &#39; + cycle + &#39; &#39; + times, verbal)


def form(level, number, verbal=True):
    &#34;&#34;&#34; **[High Level]** FORM the cells

    Args:
        level (str): Hierarchy level, could be *cell*, *row*, *col*, *module*
        number (str): Target number, could be *0*~*65535* for *cell*, *0*~*255* for *row* and *col*, *0* for *module*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    if level == &#39;cell&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_FORM + &#39; &#39; + CM.CM_RRAM_API_LEVEL_CELL + &#39; &#39; + number, verbal)
    elif level == &#39;row&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_FORM + &#39; &#39; + CM.CM_RRAM_API_LEVEL_ROW + &#39; &#39; + number, verbal)
    elif level == &#39;col&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_FORM + &#39; &#39; + CM.CM_RRAM_API_LEVEL_COL + &#39; &#39; + number, verbal)
    elif level == &#39;module&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_FORM + &#39; &#39; + CM.CM_RRAM_API_LEVEL_MODULE + &#39; &#39; + number, verbal)


def conf_set(AVDD_WR, AVDD_WL, cycle, times, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure SET operation

    Args:
        AVDD_WR (str): AVDD_WR voltage for SET
        AVDD_WL (str): AVDD_WL voltage for SET
        cycle (str): number of clock cycles per pulse for SET
        times (str): number of pulses for SET
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_SET + &#39; &#39; + AVDD_WR + &#39; &#39; + AVDD_WL + &#39; &#39; + cycle + &#39; &#39; + times, verbal)


def set(level, number, verbal=True):
    &#34;&#34;&#34; **[High Level]** SET the cells

    Args:
        level (str): Hierarchy level, could be *cell*, *row*, *col*, *module*
        number (str): Target number, could be *0*~*65535* for *cell*, *0*~*255* for *row* and *col*, *0* for *module*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    if level == &#39;cell&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_CELL   + &#39; &#39; + number, verbal)
    elif level == &#39;row&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_ROW    + &#39; &#39; + number, verbal)
    elif level == &#39;col&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_COL    + &#39; &#39; + number, verbal)
    elif level == &#39;module&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_MODULE + &#39; &#39; + number, verbal)


def conf_reset(AVDD_WR, AVDD_WL, cycle, times, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure RESET operation

    Args:
        AVDD_WR (str): AVDD_WR voltage for RESET
        AVDD_WL (str): AVDD_WL voltage for RESET
        cycle (str): number of clock cycles per pulse for RESET
        times (str): number of pulses for RESET
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_RESET + &#39; &#39; + AVDD_WR + &#39; &#39; + AVDD_WL + &#39; &#39; + cycle + &#39; &#39; + times, verbal)


def reset(level, number, verbal=True):
    &#34;&#34;&#34; **[High Level]** RESET the cells

    Args:
        level (str): Hierarchy level, could be *cell*, *row*, *col*, *module*
        number (str): Target number, could be *0*~*65535* for *cell*, *0*~*255* for *row* and *col*, *0* for *module*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    if level == &#39;cell&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_CELL   + &#39; &#39; + number, verbal)
    elif level == &#39;row&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_ROW    + &#39; &#39; + number, verbal)
    elif level == &#39;col&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_COL    + &#39; &#39; + number, verbal)
    elif level == &#39;module&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_MODULE + &#39; &#39; + number, verbal)


def set_reset(level, number, times, verbal=True):
    &#34;&#34;&#34; **[High Level]** SET and RESET the cells

    Args:
        level (str): Hierarchy level, could be *cell*, *row*, *col*, *module*
        number (str): Target number, could be *0*~*65535* for *cell*, *0*~*255* for *row* and *col*, *0* for *module*
        times (str): How many loops per set&amp;reset
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    if level == &#39;cell&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_CELL   + &#39; &#39; + number + &#39; &#39; + times, verbal)
    elif level == &#39;row&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_ROW    + &#39; &#39; + number + &#39; &#39; + times, verbal)
    elif level == &#39;col&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_COL    + &#39; &#39; + number + &#39; &#39; + times, verbal)
    elif level == &#39;module&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_MODULE + &#39; &#39; + number + &#39; &#39; + times, verbal)


def write_byte(address, value, verbal=True):
    &#34;&#34;&#34; **[High Level]** Write *value* to *address*

    Args:
        address (str): Address to be written to
        value (str): Value to be written to
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_WRITE_BYTE + &#39; &#39; + address + &#39; &#39; + value, verbal)


def write_byte_iter(address, value, verbal=True):
    &#34;&#34;&#34; **[High Level]** Write *value* to *address* iteratively, this function is more robust than *write_byte* but takes longer

    Args:
        address (str): Address to be written to
        value (str): Value to be written to
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_WRITE_BYTE_ITER + &#39; &#39; + address + &#39; &#39; + value, verbal)


def conf_read(cycle, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure READ operation

    Args:
        cycle (str): Number of clock cycles per pulse for READ
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_READ + &#39; &#39; + cycle, verbal)


def read_lane(address, data, verbal=True):
    &#34;&#34;&#34; **[High Level]** Read the *address* cell with *data* fed to the WLs

    Args:
        address (str): Address to be read from
        data (str): Value to be fed to the WLs
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The readout value of one lane.

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_READ_LANE + &#39; &#39; + address + &#39; &#39; + data, verbal)


def read_byte(address, counter, data, verbal=True):
    &#34;&#34;&#34; **[High Level]** Read the whole byte from *address* with *data* fed to the WLs and *counter* for the MAC unit

    Args:
        address (str): Address to be read from
        counter (str): so the MAC unit knows which bit the *data* is currently at
        data (str): Value to be fed to the WLs
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The readout value of one byte (8 lanes).

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_READ_BYTE + &#39; &#39; + address + &#39; &#39; + counter + &#39; &#39; + data, verbal)


def conf_ADC(offset, step, comp=&#39;0x7FFF&#39;, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure ADC settings

    Args:
        offset (str): ADC offset, from *0*~*63*, *0* for minimum offset and *63* for maximum offset
        step (str): ADC step size, from *0*~*63*, *0* for minimum step and *63* for maximum step
        comp (str): Comparator enables, from *0x0001*~*0x7FFF*, each bit controls a comparator
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_ADC + &#39; &#39; + offset + &#39; &#39; + step + &#39; &#39; + comp, verbal)


def conf_MAC(mode, resolution, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure MAC settings

    Args:
        mode (str): MAC mode, *0* for unsigned and *1* for *signed*
        resolution (str): MAC resolution *0* for 1 bit, *1* for 2 bits, *2* for 4 bits, and *3* for 8 bits
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_MAC + &#39; &#39; + mode + &#39; &#39; + resolution, verbal)


def calibrate_VRef(lane, low, high, tolerance, verbal=True):
    &#34;&#34;&#34; **[High Level]** Calibrate the internally generated reference voltages so the range would be approx. (*low*, *high*) for the current module

    Args:
        lane (str): Target ADC lane
        low (str): Target lower bound of the reference voltages
        high (str): Target upper bound of the reference voltages
        tolerance (str): Target tolerance from either *low* or *high*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        (int, int): (offset, step) which makes ADC fit the desired range.

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CAL_VREF + &#39; &#39; + lane + &#39; &#39; + low + &#39; &#39; + high + &#39; &#39; + tolerance, verbal)


def sweep_VRef(lane, low, high, step, verbal=True):
    &#34;&#34;&#34; **[High Level]** Sweep the ADC_CAL and look for all 15 internally generated reference voltages for the current module

    Args:
        lane (str): Target ADC lane
        low (str): Starting voltage for ADC_CAL
        high (str): Ending voltage for ADC_CAL
        step (str): Step for ADC_CAL
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SWEEP_VREF + &#39; &#39; + lane + &#39; &#39; + low + &#39; &#39; + high + &#39; &#39; + step, verbal)


def list_VRef(verbal=True):
    &#34;&#34;&#34; **[High Level]** List 15 internally generated reference voltages of the current module, sweep_VRef needs to be done in advance

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: 15 internally generated reference voltages of the selected RRAM Module.

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_LIST_VREF, verbal)


def clear_VRef(verbal=True):
    &#34;&#34;&#34; **[High Level]** Clear 15 internally generated reference voltages of the current module

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CLEAR_VREF, verbal)


def calibrate_VTGT_BL(verbal=True):
    &#34;&#34;&#34; **[High Level]** Calibrate VTGT_BL for the current module

    .. note::
        This function changes the values inside some cells

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.
    Returns:
        VTGT_BL which makes readout from 9 parallel HRS cells to be 0x4000.
    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CAL_VTGT_BL, verbal)


def conf_VTGT_BL(vtgt_bl, verbal=True):
    &#34;&#34;&#34; **[High Level]** Save the VTGT_BL for the current module

    Args:
        vtgt_bl (str): Voltage value for VTGT_BL.
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_VTGT_BL + &#39; &#39; + vtgt_bl, verbal)


def list_VTGT_BL(verbal=True):
    &#34;&#34;&#34; **[High Level]** List saved VTGT_BL of the current module

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The current VTGT_BL of the selected RRAM Module.

    &#34;&#34;&#34;
    return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_LIST_VTGT_BL, verbal))


def clear_VTGT_BL(verbal=True):
    &#34;&#34;&#34; **[High Level]** Clear saved VTGT_BL of the current module

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CLEAR_VTGT_BL, verbal)


def sweep_DRef(ones, verbal=True):
    &#34;&#34;&#34; **[High Level]** Calibrate decoder reference levels.

    .. note::
        This function changes the values inside some cells

    Args:
        ones (str): Could be omit or *1*~*9*, omit means do the calibration for all *1*~*9*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SWEEP_DREF + &#39; &#39; + ones, verbal)


def list_DRef(verbal=True):
    &#34;&#34;&#34; **[High Level]** List decoder reference levels of the current module

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The current decoder reference of the selected RRAM Module.

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_LIST_DREF, verbal)


def clear_DRef(ones, verbal=True):
    &#34;&#34;&#34; **[High Level]** Clear decoder reference levels.

    Args:
        ones (str): Could be omit or *1*~*9*, omit means do the calibration for all *1*~*9*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CLEAR_DREF + &#39; &#39; + ones, verbal)


def check_cell(address, verbal=True):
    &#34;&#34;&#34; **[High Level]** Check the health of the RRAM cell, this function essentially consists of SET-&gt;READ-&gt;RESET-&gt;READ.
        If the cell is healthy, the ADC raw value after SET should be smaller than the value after RESET.

    .. note::
        This function changes the values inside the cell value of &#39;address&#39;

    Args:
        address (str): Target address, could be *0*~*65535*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        (str, str): (the ADC raw value after set, the ADC raw value after reset)

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CHECK_CELL + &#39; &#39; + address, verbal)


def decode(parameters):
    &#34;&#34;&#34; Decode the command

    Args:
        parameters (list): Command in List form.

    &#34;&#34;&#34;
    # Driver functions
    if   parameters[1] == &#39;id&#39;               : id               (                                                          )
    elif parameters[1] == &#39;lane&#39;             : lane             (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;group&#39;            : group            (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;module&#39;           : module           (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;mask&#39;             : mask             (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;address&#39;          : address          (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;read&#39;             : read             (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;mac&#39;              : mac              (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;write&#39;            : write            (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;adc&#39;              : adc              (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;pg&#39;               : pg               (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;ecc&#39;              : ecc              (parameters[2], parameters[3], parameters[4],              )
    # API functions
    elif parameters[1] == &#39;reg_status&#39;       : reg_status       (                                                          )
    elif parameters[1] == &#39;env_init&#39;         : env_init         (                                                          )
    elif parameters[1] == &#39;env_status&#39;       : env_status       (                                                          )
    elif parameters[1] == &#39;mod_init&#39;         : mod_init         (                                                          )
    elif parameters[1] == &#39;mod_status&#39;       : mod_status       (                                                          )
    elif parameters[1] == &#39;mod_conf&#39;         : mod_conf         (parameters[2],                                            )
    elif parameters[1] == &#39;switch&#39;           : switch           (parameters[2],                                            )
    elif parameters[1] == &#39;conf_form&#39;        : conf_form        (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;form&#39;             : form             (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;conf_set&#39;         : conf_set         (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;set&#39;              : set              (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;set_reset&#39;        : set_reset        (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;conf_reset&#39;       : conf_reset       (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;reset&#39;            : reset            (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;write_byte&#39;       : write_byte       (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;write_byte_iter&#39;  : write_byte_iter  (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;conf_read&#39;        : conf_read        (parameters[2],                                            )
    elif parameters[1] == &#39;read_lane&#39;        : read_lane        (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;read_byte&#39;        : read_byte        (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;conf_ADC&#39;         : conf_ADC         (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;conf_MAC&#39;         : conf_MAC         (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;calibrate_VRef&#39;   : calibrate_VRef   (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;sweep_VRef&#39;       : sweep_VRef       (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;list_VRef&#39;        : list_VRef        (                                                          )
    elif parameters[1] == &#39;clear_VRef&#39;       : clear_VRef       (                                                          )
    elif parameters[1] == &#39;calibrate_VTGT_BL&#39;: calibrate_VTGT_BL(                                                          )
    elif parameters[1] == &#39;conf_VTGT_BL&#39;     : conf_VTGT_BL     (parameters[2],                                            )
    elif parameters[1] == &#39;list_VTGT_BL&#39;     : list_VTGT_BL     (                                                          )
    elif parameters[1] == &#39;clear_VTGT_BL&#39;    : clear_VTGT_BL    (                                                          )
    elif parameters[1] == &#39;sweep_DRef&#39;       : sweep_DRef       (parameters[2],                                            )
    elif parameters[1] == &#39;list_DRef&#39;        : list_DRef        (                                                          )
    elif parameters[1] == &#39;clear_DRef&#39;       : clear_DRef       (parameters[2],                                            )
    elif parameters[1] == &#39;check_cell&#39;       : check_cell       (parameters[2],                                            )
    else: PT.unknown(parameters)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="RRAM.adc"><code class="name flex">
<span>def <span class="ident">adc</span></span>(<span>action, action_type, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Configure ADC related settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>action_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>raw</em>, <em>step</em>, <em>offset</em>, <em>comp</em>, <em>hbias</em>, <em>cal</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, <em>0</em>~<em>1</em> for <em>hbias</em> <em>cal</em>, <em>0</em>~<em>63</em> for <em>step</em> <em>offset</em>, <em>0x0000</em>~<em>0x7FFF</em> for <em>comp</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>int</code></dt>
<dd>The current value of <em>action_type</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adc(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure ADC related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *raw*, *step*, *offset*, *comp*, *hbias*, *cal*
        target (str): Target number, *0*~*1* for *hbias* *cal*, *0*~*63* for *step* *offset*, *0x0000*~*0x7FFF* for *comp*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str or int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;step&#39;  :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_STEP   + &#39; &#39; + target, verbal)
        elif action_type == &#39;offset&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_OFFSET + &#39; &#39; + target, verbal)
        elif action_type == &#39;comp&#39;  :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_COMP   + &#39; &#39; + target, verbal)
        elif action_type == &#39;hbias&#39; :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_HBIAS  + &#39; &#39; + target, verbal)
        elif action_type == &#39;cal&#39;   :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ADC_CAL    + &#39; &#39; + target, verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;adc&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;raw&#39;   : return     PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_RAW   , verbal)
        elif action_type == &#39;step&#39;  : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_STEP  , verbal))
        elif action_type == &#39;offset&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_OFFSET, verbal))
        elif action_type == &#39;comp&#39;  : return     PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_COMP  , verbal)
        elif action_type == &#39;hbias&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_HBIAS , verbal))
        elif action_type == &#39;cal&#39;   : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ADC_CAL   , verbal))
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;adc&#39;, action, action_type, target])
    else: PT.unknown([&#39;RRAM&#39;, &#39;adc&#39;, action, action_type, target])</code></pre>
</details>
</dd>
<dt id="RRAM.address"><code class="name flex">
<span>def <span class="ident">address</span></span>(<span>action, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Set/Get the RRAM module address register</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target address, from <em>0</em>~<em>65535</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The current address.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def address(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the RRAM module address register

    Args:
        action (str): Could be *set* or *get*
        target (str): Target address, from *0*~*65535*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The current address.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADDRESS + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ADDRESS + &#39; &#39; + CM.CM_RRAM_GET, verbal))
    else: PT.unknown([&#39;RRAM&#39;, &#39;address&#39;, action, target])</code></pre>
</details>
</dd>
<dt id="RRAM.calibrate_VRef"><code class="name flex">
<span>def <span class="ident">calibrate_VRef</span></span>(<span>lane, low, high, tolerance, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Calibrate the internally generated reference voltages so the range would be approx. (<em>low</em>, <em>high</em>) for the current module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code>str</code></dt>
<dd>Target ADC lane</dd>
<dt><strong><code>low</code></strong> :&ensp;<code>str</code></dt>
<dd>Target lower bound of the reference voltages</dd>
<dt><strong><code>high</code></strong> :&ensp;<code>str</code></dt>
<dd>Target upper bound of the reference voltages</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>str</code></dt>
<dd>Target tolerance from either <em>low</em> or <em>high</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(int, int): (offset, step) which makes ADC fit the desired range.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibrate_VRef(lane, low, high, tolerance, verbal=True):
    &#34;&#34;&#34; **[High Level]** Calibrate the internally generated reference voltages so the range would be approx. (*low*, *high*) for the current module

    Args:
        lane (str): Target ADC lane
        low (str): Target lower bound of the reference voltages
        high (str): Target upper bound of the reference voltages
        tolerance (str): Target tolerance from either *low* or *high*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        (int, int): (offset, step) which makes ADC fit the desired range.

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CAL_VREF + &#39; &#39; + lane + &#39; &#39; + low + &#39; &#39; + high + &#39; &#39; + tolerance, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.calibrate_VTGT_BL"><code class="name flex">
<span>def <span class="ident">calibrate_VTGT_BL</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Calibrate VTGT_BL for the current module</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes the values inside some cells</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>VTGT_BL which makes readout from 9 parallel HRS cells to be 0x4000.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibrate_VTGT_BL(verbal=True):
    &#34;&#34;&#34; **[High Level]** Calibrate VTGT_BL for the current module

    .. note::
        This function changes the values inside some cells

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.
    Returns:
        VTGT_BL which makes readout from 9 parallel HRS cells to be 0x4000.
    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CAL_VTGT_BL, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.check_cell"><code class="name flex">
<span>def <span class="ident">check_cell</span></span>(<span>address, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Check the health of the RRAM cell, this function essentially consists of SET-&gt;READ-&gt;RESET-&gt;READ.
If the cell is healthy, the ADC raw value after SET should be smaller than the value after RESET.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes the values inside the cell value of 'address'</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Target address, could be <em>0</em>~<em>65535</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(str, str): (the ADC raw value after set, the ADC raw value after reset)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_cell(address, verbal=True):
    &#34;&#34;&#34; **[High Level]** Check the health of the RRAM cell, this function essentially consists of SET-&gt;READ-&gt;RESET-&gt;READ.
        If the cell is healthy, the ADC raw value after SET should be smaller than the value after RESET.

    .. note::
        This function changes the values inside the cell value of &#39;address&#39;

    Args:
        address (str): Target address, could be *0*~*65535*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        (str, str): (the ADC raw value after set, the ADC raw value after reset)

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CHECK_CELL + &#39; &#39; + address, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.clear_DRef"><code class="name flex">
<span>def <span class="ident">clear_DRef</span></span>(<span>ones, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Clear decoder reference levels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ones</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be omit or <em>1</em>~<em>9</em>, omit means do the calibration for all <em>1</em>~<em>9</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_DRef(ones, verbal=True):
    &#34;&#34;&#34; **[High Level]** Clear decoder reference levels.

    Args:
        ones (str): Could be omit or *1*~*9*, omit means do the calibration for all *1*~*9*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CLEAR_DREF + &#39; &#39; + ones, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.clear_VRef"><code class="name flex">
<span>def <span class="ident">clear_VRef</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Clear 15 internally generated reference voltages of the current module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_VRef(verbal=True):
    &#34;&#34;&#34; **[High Level]** Clear 15 internally generated reference voltages of the current module

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CLEAR_VREF, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.clear_VTGT_BL"><code class="name flex">
<span>def <span class="ident">clear_VTGT_BL</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Clear saved VTGT_BL of the current module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_VTGT_BL(verbal=True):
    &#34;&#34;&#34; **[High Level]** Clear saved VTGT_BL of the current module

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CLEAR_VTGT_BL, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.conf_ADC"><code class="name flex">
<span>def <span class="ident">conf_ADC</span></span>(<span>offset, step, comp='0x7FFF', verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Configure ADC settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>offset</code></strong> :&ensp;<code>str</code></dt>
<dd>ADC offset, from <em>0</em>~<em>63</em>, <em>0</em> for minimum offset and <em>63</em> for maximum offset</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>str</code></dt>
<dd>ADC step size, from <em>0</em>~<em>63</em>, <em>0</em> for minimum step and <em>63</em> for maximum step</dd>
<dt><strong><code>comp</code></strong> :&ensp;<code>str</code></dt>
<dd>Comparator enables, from <em>0x0001</em>~<em>0x7FFF</em>, each bit controls a comparator</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conf_ADC(offset, step, comp=&#39;0x7FFF&#39;, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure ADC settings

    Args:
        offset (str): ADC offset, from *0*~*63*, *0* for minimum offset and *63* for maximum offset
        step (str): ADC step size, from *0*~*63*, *0* for minimum step and *63* for maximum step
        comp (str): Comparator enables, from *0x0001*~*0x7FFF*, each bit controls a comparator
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_ADC + &#39; &#39; + offset + &#39; &#39; + step + &#39; &#39; + comp, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.conf_MAC"><code class="name flex">
<span>def <span class="ident">conf_MAC</span></span>(<span>mode, resolution, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Configure MAC settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>MAC mode, <em>0</em> for unsigned and <em>1</em> for <em>signed</em></dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>str</code></dt>
<dd>MAC resolution <em>0</em> for 1 bit, <em>1</em> for 2 bits, <em>2</em> for 4 bits, and <em>3</em> for 8 bits</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conf_MAC(mode, resolution, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure MAC settings

    Args:
        mode (str): MAC mode, *0* for unsigned and *1* for *signed*
        resolution (str): MAC resolution *0* for 1 bit, *1* for 2 bits, *2* for 4 bits, and *3* for 8 bits
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_MAC + &#39; &#39; + mode + &#39; &#39; + resolution, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.conf_VTGT_BL"><code class="name flex">
<span>def <span class="ident">conf_VTGT_BL</span></span>(<span>vtgt_bl, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Save the VTGT_BL for the current module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vtgt_bl</code></strong> :&ensp;<code>str</code></dt>
<dd>Voltage value for VTGT_BL.</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conf_VTGT_BL(vtgt_bl, verbal=True):
    &#34;&#34;&#34; **[High Level]** Save the VTGT_BL for the current module

    Args:
        vtgt_bl (str): Voltage value for VTGT_BL.
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_VTGT_BL + &#39; &#39; + vtgt_bl, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.conf_form"><code class="name flex">
<span>def <span class="ident">conf_form</span></span>(<span>AVDD_WR, AVDD_WL, cycle, times, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Configure FORM operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>AVDD_WR</code></strong> :&ensp;<code>str</code></dt>
<dd>AVDD_WR voltage for FORM</dd>
<dt><strong><code>AVDD_WL</code></strong> :&ensp;<code>str</code></dt>
<dd>AVDD_WL voltage for FORM</dd>
<dt><strong><code>cycle</code></strong> :&ensp;<code>str</code></dt>
<dd>number of clock cycles per pulse for FORM</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>str</code></dt>
<dd>number of pulses for FORM</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conf_form(AVDD_WR, AVDD_WL, cycle, times, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure FORM operation

    Args:
        AVDD_WR (str): AVDD_WR voltage for FORM
        AVDD_WL (str): AVDD_WL voltage for FORM
        cycle (str): number of clock cycles per pulse for FORM
        times (str): number of pulses for FORM
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_FORM + &#39; &#39; + AVDD_WR + &#39; &#39; + AVDD_WL + &#39; &#39; + cycle + &#39; &#39; + times, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.conf_read"><code class="name flex">
<span>def <span class="ident">conf_read</span></span>(<span>cycle, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Configure READ operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cycle</code></strong> :&ensp;<code>str</code></dt>
<dd>Number of clock cycles per pulse for READ</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conf_read(cycle, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure READ operation

    Args:
        cycle (str): Number of clock cycles per pulse for READ
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_READ + &#39; &#39; + cycle, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.conf_reset"><code class="name flex">
<span>def <span class="ident">conf_reset</span></span>(<span>AVDD_WR, AVDD_WL, cycle, times, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Configure RESET operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>AVDD_WR</code></strong> :&ensp;<code>str</code></dt>
<dd>AVDD_WR voltage for RESET</dd>
<dt><strong><code>AVDD_WL</code></strong> :&ensp;<code>str</code></dt>
<dd>AVDD_WL voltage for RESET</dd>
<dt><strong><code>cycle</code></strong> :&ensp;<code>str</code></dt>
<dd>number of clock cycles per pulse for RESET</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>str</code></dt>
<dd>number of pulses for RESET</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conf_reset(AVDD_WR, AVDD_WL, cycle, times, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure RESET operation

    Args:
        AVDD_WR (str): AVDD_WR voltage for RESET
        AVDD_WL (str): AVDD_WL voltage for RESET
        cycle (str): number of clock cycles per pulse for RESET
        times (str): number of pulses for RESET
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_RESET + &#39; &#39; + AVDD_WR + &#39; &#39; + AVDD_WL + &#39; &#39; + cycle + &#39; &#39; + times, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.conf_set"><code class="name flex">
<span>def <span class="ident">conf_set</span></span>(<span>AVDD_WR, AVDD_WL, cycle, times, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Configure SET operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>AVDD_WR</code></strong> :&ensp;<code>str</code></dt>
<dd>AVDD_WR voltage for SET</dd>
<dt><strong><code>AVDD_WL</code></strong> :&ensp;<code>str</code></dt>
<dd>AVDD_WL voltage for SET</dd>
<dt><strong><code>cycle</code></strong> :&ensp;<code>str</code></dt>
<dd>number of clock cycles per pulse for SET</dd>
<dt><strong><code>times</code></strong> :&ensp;<code>str</code></dt>
<dd>number of pulses for SET</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conf_set(AVDD_WR, AVDD_WL, cycle, times, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure SET operation

    Args:
        AVDD_WR (str): AVDD_WR voltage for SET
        AVDD_WL (str): AVDD_WL voltage for SET
        cycle (str): number of clock cycles per pulse for SET
        times (str): number of pulses for SET
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_CONF_SET + &#39; &#39; + AVDD_WR + &#39; &#39; + AVDD_WL + &#39; &#39; + cycle + &#39; &#39; + times, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode the command</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parameters</code></strong> :&ensp;<code>list</code></dt>
<dd>Command in List form.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(parameters):
    &#34;&#34;&#34; Decode the command

    Args:
        parameters (list): Command in List form.

    &#34;&#34;&#34;
    # Driver functions
    if   parameters[1] == &#39;id&#39;               : id               (                                                          )
    elif parameters[1] == &#39;lane&#39;             : lane             (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;group&#39;            : group            (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;module&#39;           : module           (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;mask&#39;             : mask             (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;address&#39;          : address          (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;read&#39;             : read             (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;mac&#39;              : mac              (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;write&#39;            : write            (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;adc&#39;              : adc              (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;pg&#39;               : pg               (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;ecc&#39;              : ecc              (parameters[2], parameters[3], parameters[4],              )
    # API functions
    elif parameters[1] == &#39;reg_status&#39;       : reg_status       (                                                          )
    elif parameters[1] == &#39;env_init&#39;         : env_init         (                                                          )
    elif parameters[1] == &#39;env_status&#39;       : env_status       (                                                          )
    elif parameters[1] == &#39;mod_init&#39;         : mod_init         (                                                          )
    elif parameters[1] == &#39;mod_status&#39;       : mod_status       (                                                          )
    elif parameters[1] == &#39;mod_conf&#39;         : mod_conf         (parameters[2],                                            )
    elif parameters[1] == &#39;switch&#39;           : switch           (parameters[2],                                            )
    elif parameters[1] == &#39;conf_form&#39;        : conf_form        (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;form&#39;             : form             (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;conf_set&#39;         : conf_set         (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;set&#39;              : set              (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;set_reset&#39;        : set_reset        (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;conf_reset&#39;       : conf_reset       (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;reset&#39;            : reset            (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;write_byte&#39;       : write_byte       (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;write_byte_iter&#39;  : write_byte_iter  (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;conf_read&#39;        : conf_read        (parameters[2],                                            )
    elif parameters[1] == &#39;read_lane&#39;        : read_lane        (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;read_byte&#39;        : read_byte        (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;conf_ADC&#39;         : conf_ADC         (parameters[2], parameters[3], parameters[4],              )
    elif parameters[1] == &#39;conf_MAC&#39;         : conf_MAC         (parameters[2], parameters[3],                             )
    elif parameters[1] == &#39;calibrate_VRef&#39;   : calibrate_VRef   (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;sweep_VRef&#39;       : sweep_VRef       (parameters[2], parameters[3], parameters[4], parameters[5])
    elif parameters[1] == &#39;list_VRef&#39;        : list_VRef        (                                                          )
    elif parameters[1] == &#39;clear_VRef&#39;       : clear_VRef       (                                                          )
    elif parameters[1] == &#39;calibrate_VTGT_BL&#39;: calibrate_VTGT_BL(                                                          )
    elif parameters[1] == &#39;conf_VTGT_BL&#39;     : conf_VTGT_BL     (parameters[2],                                            )
    elif parameters[1] == &#39;list_VTGT_BL&#39;     : list_VTGT_BL     (                                                          )
    elif parameters[1] == &#39;clear_VTGT_BL&#39;    : clear_VTGT_BL    (                                                          )
    elif parameters[1] == &#39;sweep_DRef&#39;       : sweep_DRef       (parameters[2],                                            )
    elif parameters[1] == &#39;list_DRef&#39;        : list_DRef        (                                                          )
    elif parameters[1] == &#39;clear_DRef&#39;       : clear_DRef       (parameters[2],                                            )
    elif parameters[1] == &#39;check_cell&#39;       : check_cell       (parameters[2],                                            )
    else: PT.unknown(parameters)</code></pre>
</details>
</dd>
<dt id="RRAM.ecc"><code class="name flex">
<span>def <span class="ident">ecc</span></span>(<span>action, action_type, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Configure power gating related settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em>, <em>get</em>, <em>clear</em>, or <em>check</em></dd>
<dt><strong><code>action_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>enable</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, <em>0</em>~<em>1</em> for <em>enable</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>int</code></dt>
<dd>The current value of <em>action_type</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ecc(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure power gating related settings

    Args:
        action (str): Could be *set*, *get*, *clear*, or *check*
        action_type (str): Could be *enable*
        target (str): Target number, *0*~*1* for *enable*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str or int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;enable&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ECC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_ECC_ENABLE + &#39; &#39; + target, verbal)
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;ecc&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;enable&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ECC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_ECC_ENABLE, verbal))
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;ecc&#39;, action, action_type, target])
    elif action == &#39;clear&#39;:
               PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ECC + &#39; &#39; + CM.CM_RRAM_CLEAR, verbal)
    elif action == &#39;check&#39;:
        return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_ECC + &#39; &#39; + CM.CM_RRAM_CHECK, verbal)
    else: PT.unknown([&#39;RRAM&#39;, &#39;ecc&#39;, action, action_type, target])</code></pre>
</details>
</dd>
<dt id="RRAM.env_init"><code class="name flex">
<span>def <span class="ident">env_init</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Initialize the environment configurations of the RRAM accelerator and the currently selected RRAM modules</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def env_init(verbal=True):
    &#34;&#34;&#34; **[High Level]** Initialize the environment configurations of the RRAM accelerator and the currently selected RRAM modules

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_ENV_INIT, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.env_status"><code class="name flex">
<span>def <span class="ident">env_status</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Print the environment configurations of the RRAM accelerator and the currently selected RRAM modules</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def env_status(verbal=True):
    &#34;&#34;&#34; **[High Level]** Print the environment configurations of the RRAM accelerator and the currently selected RRAM modules

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_ENV_STATUS, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.form"><code class="name flex">
<span>def <span class="ident">form</span></span>(<span>level, number, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> FORM the cells</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>Hierarchy level, could be <em>cell</em>, <em>row</em>, <em>col</em>, <em>module</em></dd>
<dt><strong><code>number</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, could be <em>0</em>~<em>65535</em> for <em>cell</em>, <em>0</em>~<em>255</em> for <em>row</em> and <em>col</em>, <em>0</em> for <em>module</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def form(level, number, verbal=True):
    &#34;&#34;&#34; **[High Level]** FORM the cells

    Args:
        level (str): Hierarchy level, could be *cell*, *row*, *col*, *module*
        number (str): Target number, could be *0*~*65535* for *cell*, *0*~*255* for *row* and *col*, *0* for *module*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    if level == &#39;cell&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_FORM + &#39; &#39; + CM.CM_RRAM_API_LEVEL_CELL + &#39; &#39; + number, verbal)
    elif level == &#39;row&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_FORM + &#39; &#39; + CM.CM_RRAM_API_LEVEL_ROW + &#39; &#39; + number, verbal)
    elif level == &#39;col&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_FORM + &#39; &#39; + CM.CM_RRAM_API_LEVEL_COL + &#39; &#39; + number, verbal)
    elif level == &#39;module&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_FORM + &#39; &#39; + CM.CM_RRAM_API_LEVEL_MODULE + &#39; &#39; + number, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.group"><code class="name flex">
<span>def <span class="ident">group</span></span>(<span>action, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Set/Get the selected group for the Vector module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target group number, from <em>0</em>~<em>35</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The selected group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the selected group for the Vector module

    Args:
        action (str): Could be *set* or *get*
        target (str): Target group number, from *0*~*35*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The selected group.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_GROUP + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_GROUP + &#39; &#39; + CM.CM_RRAM_GET, verbal))
    else: PT.unknown([&#39;RRAM&#39;, &#39;group&#39;, action, target])</code></pre>
</details>
</dd>
<dt id="RRAM.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Get the ID of the RRAM Modules</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The ID of the RRAM Modules. (should be <em>0x01314520</em>)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id (verbal=True):
    &#34;&#34;&#34; **[Low Level]** Get the ID of the RRAM Modules

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The ID of the RRAM Modules. (should be *0x01314520*)

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_PID, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.lane"><code class="name flex">
<span>def <span class="ident">lane</span></span>(<span>action, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Set/Get the selected ADC lane</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target lane number, from <em>0</em>~<em>7</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The selected lane.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lane(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the selected ADC lane

    Args:
        action (str): Could be *set* or *get*
        target (str): Target lane number, from *0*~*7*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The selected lane.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_LANE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_LANE + &#39; &#39; + CM.CM_RRAM_GET, verbal))
    else: PT.unknown([&#39;RRAM&#39;, &#39;lane&#39;, action, target])</code></pre>
</details>
</dd>
<dt id="RRAM.list_DRef"><code class="name flex">
<span>def <span class="ident">list_DRef</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> List decoder reference levels of the current module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The current decoder reference of the selected RRAM Module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_DRef(verbal=True):
    &#34;&#34;&#34; **[High Level]** List decoder reference levels of the current module

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The current decoder reference of the selected RRAM Module.

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_LIST_DREF, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.list_VRef"><code class="name flex">
<span>def <span class="ident">list_VRef</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> List 15 internally generated reference voltages of the current module, sweep_VRef needs to be done in advance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>15 internally generated reference voltages of the selected RRAM Module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_VRef(verbal=True):
    &#34;&#34;&#34; **[High Level]** List 15 internally generated reference voltages of the current module, sweep_VRef needs to be done in advance

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: 15 internally generated reference voltages of the selected RRAM Module.

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_LIST_VREF, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.list_VTGT_BL"><code class="name flex">
<span>def <span class="ident">list_VTGT_BL</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> List saved VTGT_BL of the current module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The current VTGT_BL of the selected RRAM Module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_VTGT_BL(verbal=True):
    &#34;&#34;&#34; **[High Level]** List saved VTGT_BL of the current module

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The current VTGT_BL of the selected RRAM Module.

    &#34;&#34;&#34;
    return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_LIST_VTGT_BL, verbal))</code></pre>
</details>
</dd>
<dt id="RRAM.mac"><code class="name flex">
<span>def <span class="ident">mac</span></span>(<span>action, action_type, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Configure mac related settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>action_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>status</em>, <em>result</em>, <em>mode</em>, <em>resolution</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, <em>0</em>~<em>1</em> for <em>mode</em>, <em>0</em>~<em>3</em> for <em>resolution</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The current value of <em>action_type</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mac(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure mac related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *status*, *result*, *mode*, *resolution*
        target (str): Target number, *0*~*1* for *mode*, *0*~*3* for *resolution*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;mode&#39;      :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_MAC_MODE       + &#39; &#39; + target, verbal)
        elif action_type == &#39;resolution&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_MAC_RESOLUTION + &#39; &#39; + target, verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;mac&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;status&#39;    : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_MAC_STATUS    , verbal))
        elif action_type == &#39;mode&#39;      : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_MAC_MODE      , verbal))
        elif action_type == &#39;resolution&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_MAC_RESOLUTION, verbal))
        elif action_type == &#39;result&#39;    : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MAC + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_MAC_RESULT    , verbal))
        else: PT.unknown([&#39;RRAM&#39;, &#39;mac&#39;, action, action_type, target])
    else: PT.unknown([&#39;RRAM&#39;, &#39;mac&#39;, action, action_type, target])</code></pre>
</details>
</dd>
<dt id="RRAM.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>action, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Set/Get the RRAM module selection mask register</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target RRAM module selection mask, from <em>0x00000001</em>~<em>0xFFFFFFFF</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The current mask.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the RRAM module selection mask register

    Args:
        action (str): Could be *set* or *get*
        target (str): Target RRAM module selection mask, from *0x00000001*~*0xFFFFFFFF*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The current mask.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MASK + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MASK + &#39; &#39; + CM.CM_RRAM_GET, verbal)
    else: PT.unknown([&#39;RRAM&#39;, &#39;mask&#39;, action, target])</code></pre>
</details>
</dd>
<dt id="RRAM.mod_conf"><code class="name flex">
<span>def <span class="ident">mod_conf</span></span>(<span>status, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Configure the current module floorplan status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mod_conf(status, verbal=True):
    &#34;&#34;&#34; **[High Level]** Configure the current module floorplan status

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    status_dict = {
        &#39;C&#39;: CM.CM_RRAM_API_MOD_STATUS_CLEAN,
        &#39;F&#39;: CM.CM_RRAM_API_MOD_STATUS_FORMED,
        &#39;P&#39;: CM.CM_RRAM_API_MOD_STATUS_PARTIALLY_FORMED,
        &#39;U&#39;: CM.CM_RRAM_API_MOD_STATUS_USED,
        &#39;B&#39;: CM.CM_RRAM_API_MOD_STATUS_BROKEN,
        &#39;A&#39;: CM.CM_RRAM_API_MOD_STATUS_ADC_FATAL,
        &#39;?&#39;: CM.CM_RRAM_API_MOD_STATUS_UNKNOWN,
    }
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_MOD_CONF + &#39; &#39; + str(status_dict[status]), verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.mod_init"><code class="name flex">
<span>def <span class="ident">mod_init</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Initialize the module floorplan status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mod_init(verbal=True):
    &#34;&#34;&#34; **[High Level]** Initialize the module floorplan status

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_MOD_INIT, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.mod_status"><code class="name flex">
<span>def <span class="ident">mod_status</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Print the module floorplan status</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mod_status(verbal=True):
    &#34;&#34;&#34; **[High Level]** Print the module floorplan status

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_MOD_STATUS, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.module"><code class="name flex">
<span>def <span class="ident">module</span></span>(<span>action, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Set/Get the selected RRAM module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target RRAM module number, from <em>0</em>~<em>287</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The selected module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def module(action, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Set/Get the selected RRAM module

    Args:
        action (str): Could be *set* or *get*
        target (str): Target RRAM module number, from *0*~*287*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The selected module.

    &#34;&#34;&#34;
    if   action == &#39;set&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MODULE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + target, verbal)
    elif action == &#39;get&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_MODULE + &#39; &#39; + CM.CM_RRAM_GET, verbal))
    else: PT.unknown([&#39;RRAM&#39;, &#39;module&#39;, action, target])</code></pre>
</details>
</dd>
<dt id="RRAM.pg"><code class="name flex">
<span>def <span class="ident">pg</span></span>(<span>action, action_type, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Configure power gating related settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>action_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>disable</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, <em>0</em>~<em>1</em> for <em>disable</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The current value of <em>action_type</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pg(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure power gating related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *disable*
        target (str): Target number, *0*~*1* for *disable*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;disable&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_PG + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_PG_DISABLE + &#39; &#39; + target, verbal)
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;pg&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;disable&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_PG + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_PG_DISABLE, verbal))
        else:
            PT.unknown([&#39;RRAM&#39;, &#39;pg&#39;, action, action_type, target])
    else: PT.unknown([&#39;RRAM&#39;, &#39;pg&#39;, action, action_type, target])</code></pre>
</details>
</dd>
<dt id="RRAM.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>action, action_type, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Configure read related settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>action_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>status</em>, <em>enable</em>, <em>cycle</em>, <em>source</em>, <em>counter</em>, <em>data</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, <em>0</em>~<em>1</em> for <em>enable</em> <em>source</em>, <em>0</em>~<em>255</em> for <em>cycle</em>, and <em>0x1</em>~<em>0x1FF</em> for <em>data</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>int</code></dt>
<dd>The current value of <em>action_type</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure read related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *status*, *enable*, *cycle*, *source*, *counter*, *data*
        target (str): Target number, *0*~*1* for *enable* *source*, *0*~*255* for *cycle*, and *0x1*~*0x1FF* for *data*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str or int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;enable&#39; :        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_ENABLE  + &#39; &#39; + target, verbal)
        elif action_type == &#39;cycle&#39;  :        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_CYCLE   + &#39; &#39; + target, verbal)
        elif action_type == &#39;source&#39; :        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_SOURCE  + &#39; &#39; + target, verbal)
        elif action_type == &#39;counter&#39;:        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_COUNTER + &#39; &#39; + target, verbal)
        elif action_type == &#39;data&#39;   :        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_READ_DATA    + &#39; &#39; + target, verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;read&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;enable&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_ENABLE , verbal))
        elif action_type == &#39;status&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_STATUS , verbal))
        elif action_type == &#39;cycle&#39;  : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_CYCLE  , verbal))
        elif action_type == &#39;source&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_SOURCE , verbal))
        elif action_type == &#39;counter&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_COUNTER, verbal))
        elif action_type == &#39;data&#39;   : return     PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_READ_DATA   , verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;read&#39;, action, action_type, target])
    elif action == &#39;toggle&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_READ + &#39; &#39; + CM.CM_RRAM_TOGGLE, verbal)
    else: PT.unknown([&#39;RRAM&#39;, &#39;read&#39;, action, action_type, target])</code></pre>
</details>
</dd>
<dt id="RRAM.read_byte"><code class="name flex">
<span>def <span class="ident">read_byte</span></span>(<span>address, counter, data, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Read the whole byte from <em>address</em> with <em>data</em> fed to the WLs and <em>counter</em> for the MAC unit</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Address to be read from</dd>
<dt><strong><code>counter</code></strong> :&ensp;<code>str</code></dt>
<dd>so the MAC unit knows which bit the <em>data</em> is currently at</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to be fed to the WLs</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The readout value of one byte (8 lanes).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_byte(address, counter, data, verbal=True):
    &#34;&#34;&#34; **[High Level]** Read the whole byte from *address* with *data* fed to the WLs and *counter* for the MAC unit

    Args:
        address (str): Address to be read from
        counter (str): so the MAC unit knows which bit the *data* is currently at
        data (str): Value to be fed to the WLs
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The readout value of one byte (8 lanes).

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_READ_BYTE + &#39; &#39; + address + &#39; &#39; + counter + &#39; &#39; + data, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.read_lane"><code class="name flex">
<span>def <span class="ident">read_lane</span></span>(<span>address, data, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Read the <em>address</em> cell with <em>data</em> fed to the WLs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Address to be read from</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to be fed to the WLs</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The readout value of one lane.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_lane(address, data, verbal=True):
    &#34;&#34;&#34; **[High Level]** Read the *address* cell with *data* fed to the WLs

    Args:
        address (str): Address to be read from
        data (str): Value to be fed to the WLs
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    Returns:
        str: The readout value of one lane.

    &#34;&#34;&#34;
    return PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_READ_LANE + &#39; &#39; + address + &#39; &#39; + data, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.reg_status"><code class="name flex">
<span>def <span class="ident">reg_status</span></span>(<span>verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Print the register status of the RRAM accelerator</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reg_status(verbal=True):
    &#34;&#34;&#34; **[High Level]** Print the register status of the RRAM accelerator

    Args:
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_REG_STATUS, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>level, number, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> RESET the cells</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>Hierarchy level, could be <em>cell</em>, <em>row</em>, <em>col</em>, <em>module</em></dd>
<dt><strong><code>number</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, could be <em>0</em>~<em>65535</em> for <em>cell</em>, <em>0</em>~<em>255</em> for <em>row</em> and <em>col</em>, <em>0</em> for <em>module</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(level, number, verbal=True):
    &#34;&#34;&#34; **[High Level]** RESET the cells

    Args:
        level (str): Hierarchy level, could be *cell*, *row*, *col*, *module*
        number (str): Target number, could be *0*~*65535* for *cell*, *0*~*255* for *row* and *col*, *0* for *module*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    if level == &#39;cell&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_CELL   + &#39; &#39; + number, verbal)
    elif level == &#39;row&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_ROW    + &#39; &#39; + number, verbal)
    elif level == &#39;col&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_COL    + &#39; &#39; + number, verbal)
    elif level == &#39;module&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_MODULE + &#39; &#39; + number, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>level, number, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> SET the cells</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>Hierarchy level, could be <em>cell</em>, <em>row</em>, <em>col</em>, <em>module</em></dd>
<dt><strong><code>number</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, could be <em>0</em>~<em>65535</em> for <em>cell</em>, <em>0</em>~<em>255</em> for <em>row</em> and <em>col</em>, <em>0</em> for <em>module</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(level, number, verbal=True):
    &#34;&#34;&#34; **[High Level]** SET the cells

    Args:
        level (str): Hierarchy level, could be *cell*, *row*, *col*, *module*
        number (str): Target number, could be *0*~*65535* for *cell*, *0*~*255* for *row* and *col*, *0* for *module*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    if level == &#39;cell&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_CELL   + &#39; &#39; + number, verbal)
    elif level == &#39;row&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_ROW    + &#39; &#39; + number, verbal)
    elif level == &#39;col&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_COL    + &#39; &#39; + number, verbal)
    elif level == &#39;module&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_MODULE + &#39; &#39; + number, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.set_reset"><code class="name flex">
<span>def <span class="ident">set_reset</span></span>(<span>level, number, times, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> SET and RESET the cells</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code></dt>
<dd>Hierarchy level, could be <em>cell</em>, <em>row</em>, <em>col</em>, <em>module</em></dd>
<dt><strong><code>number</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, could be <em>0</em>~<em>65535</em> for <em>cell</em>, <em>0</em>~<em>255</em> for <em>row</em> and <em>col</em>, <em>0</em> for <em>module</em></dd>
<dt><strong><code>times</code></strong> :&ensp;<code>str</code></dt>
<dd>How many loops per set&amp;reset</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_reset(level, number, times, verbal=True):
    &#34;&#34;&#34; **[High Level]** SET and RESET the cells

    Args:
        level (str): Hierarchy level, could be *cell*, *row*, *col*, *module*
        number (str): Target number, could be *0*~*65535* for *cell*, *0*~*255* for *row* and *col*, *0* for *module*
        times (str): How many loops per set&amp;reset
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    if level == &#39;cell&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_CELL   + &#39; &#39; + number + &#39; &#39; + times, verbal)
    elif level == &#39;row&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_ROW    + &#39; &#39; + number + &#39; &#39; + times, verbal)
    elif level == &#39;col&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_COL    + &#39; &#39; + number + &#39; &#39; + times, verbal)
    elif level == &#39;module&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SET_RESET + &#39; &#39; + CM.CM_RRAM_API_LEVEL_MODULE + &#39; &#39; + number + &#39; &#39; + times, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.sweep_DRef"><code class="name flex">
<span>def <span class="ident">sweep_DRef</span></span>(<span>ones, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Calibrate decoder reference levels.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes the values inside some cells</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ones</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be omit or <em>1</em>~<em>9</em>, omit means do the calibration for all <em>1</em>~<em>9</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sweep_DRef(ones, verbal=True):
    &#34;&#34;&#34; **[High Level]** Calibrate decoder reference levels.

    .. note::
        This function changes the values inside some cells

    Args:
        ones (str): Could be omit or *1*~*9*, omit means do the calibration for all *1*~*9*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SWEEP_DREF + &#39; &#39; + ones, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.sweep_VRef"><code class="name flex">
<span>def <span class="ident">sweep_VRef</span></span>(<span>lane, low, high, step, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Sweep the ADC_CAL and look for all 15 internally generated reference voltages for the current module</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lane</code></strong> :&ensp;<code>str</code></dt>
<dd>Target ADC lane</dd>
<dt><strong><code>low</code></strong> :&ensp;<code>str</code></dt>
<dd>Starting voltage for ADC_CAL</dd>
<dt><strong><code>high</code></strong> :&ensp;<code>str</code></dt>
<dd>Ending voltage for ADC_CAL</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>str</code></dt>
<dd>Step for ADC_CAL</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sweep_VRef(lane, low, high, step, verbal=True):
    &#34;&#34;&#34; **[High Level]** Sweep the ADC_CAL and look for all 15 internally generated reference voltages for the current module

    Args:
        lane (str): Target ADC lane
        low (str): Starting voltage for ADC_CAL
        high (str): Ending voltage for ADC_CAL
        step (str): Step for ADC_CAL
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SWEEP_VREF + &#39; &#39; + lane + &#39; &#39; + low + &#39; &#39; + high + &#39; &#39; + step, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.switch"><code class="name flex">
<span>def <span class="ident">switch</span></span>(<span>index, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Switch to module <em>index</em> and configure related things. (ex. ADC, VTGT_BL &hellip; etc)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>str</code></dt>
<dd>Target RRAM Module, from <em>0</em> ~ <em>287</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switch(index, verbal=True):
    &#34;&#34;&#34; **[High Level]** Switch to module *index* and configure related things. (ex. ADC, VTGT_BL ... etc)

    Args:
        index (str): Target RRAM Module, from *0* ~ *287*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_SWITCH + &#39; &#39; + index, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>action, action_type, target, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[Low Level]</strong> Configure read related settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>set</em> or <em>get</em></dd>
<dt><strong><code>action_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Could be <em>status</em>, <em>enable</em>, <em>cycle</em>, <em>mode</em></dd>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>Target number, <em>0</em>~<em>1</em> for <em>enable</em> <em>mode</em>, <em>0</em>~<em>65535</em> for <em>cycle</em></dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The current value of <em>action_type</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(action, action_type, target, verbal=True):
    &#34;&#34;&#34; **[Low Level]** Configure read related settings

    Args:
        action (str): Could be *set* or *get*
        action_type (str): Could be *status*, *enable*, *cycle*, *mode*
        target (str): Target number, *0*~*1* for *enable* *mode*, *0*~*65535* for *cycle*
        verbal (bool, optional): Whether to print the response or not. Defaults to True.
    Returns:
        int: The current value of *action_type*.

    &#34;&#34;&#34;
    if action == &#39;set&#39;:
        if   action_type == &#39;enable&#39;:            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_WRITE_ENABLE + &#39; &#39; + target, verbal)
        elif action_type == &#39;cycle&#39; :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_WRITE_CYCLE  + &#39; &#39; + target, verbal)
        elif action_type == &#39;mode&#39;  :            PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_SET + &#39; &#39; + CM.CM_RRAM_WRITE_MODE   + &#39; &#39; + target, verbal)
        else: PT.unknown([&#39;RRAM&#39;, &#39;write&#39;, action, action_type, target])
    elif action == &#39;get&#39;:
        if   action_type == &#39;enable&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_WRITE_ENABLE, verbal))
        elif action_type == &#39;status&#39;: return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_WRITE_STATUS, verbal))
        elif action_type == &#39;cycle&#39; : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_WRITE_CYCLE , verbal))
        elif action_type == &#39;mode&#39;  : return int(PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_GET + &#39; &#39; + CM.CM_RRAM_WRITE_MODE  , verbal))
        else: PT.unknown([&#39;RRAM&#39;, &#39;write&#39;, action, action_type, target])
    elif action == &#39;trigger&#39;:
        PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_WRITE + &#39; &#39; + CM.CM_RRAM_TRIGGER, verbal)
    else: PT.unknown([&#39;RRAM&#39;, &#39;write&#39;, action, action_type, target])</code></pre>
</details>
</dd>
<dt id="RRAM.write_byte"><code class="name flex">
<span>def <span class="ident">write_byte</span></span>(<span>address, value, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Write <em>value</em> to <em>address</em></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Address to be written to</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to be written to</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_byte(address, value, verbal=True):
    &#34;&#34;&#34; **[High Level]** Write *value* to *address*

    Args:
        address (str): Address to be written to
        value (str): Value to be written to
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_WRITE_BYTE + &#39; &#39; + address + &#39; &#39; + value, verbal)</code></pre>
</details>
</dd>
<dt id="RRAM.write_byte_iter"><code class="name flex">
<span>def <span class="ident">write_byte_iter</span></span>(<span>address, value, verbal=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>[High Level]</strong> Write <em>value</em> to <em>address</em> iteratively, this function is more robust than <em>write_byte</em> but takes longer</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Address to be written to</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to be written to</dd>
<dt><strong><code>verbal</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the response or not. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_byte_iter(address, value, verbal=True):
    &#34;&#34;&#34; **[High Level]** Write *value* to *address* iteratively, this function is more robust than *write_byte* but takes longer

    Args:
        address (str): Address to be written to
        value (str): Value to be written to
        verbal (bool, optional): Whether to print the response or not. Defaults to True.

    &#34;&#34;&#34;
    PT.send_command(CM.CM_RRAM + &#39; &#39; + CM.CM_RRAM_API_WRITE_BYTE_ITER + &#39; &#39; + address + &#39; &#39; + value, verbal)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="RRAM.adc" href="#RRAM.adc">adc</a></code></li>
<li><code><a title="RRAM.address" href="#RRAM.address">address</a></code></li>
<li><code><a title="RRAM.calibrate_VRef" href="#RRAM.calibrate_VRef">calibrate_VRef</a></code></li>
<li><code><a title="RRAM.calibrate_VTGT_BL" href="#RRAM.calibrate_VTGT_BL">calibrate_VTGT_BL</a></code></li>
<li><code><a title="RRAM.check_cell" href="#RRAM.check_cell">check_cell</a></code></li>
<li><code><a title="RRAM.clear_DRef" href="#RRAM.clear_DRef">clear_DRef</a></code></li>
<li><code><a title="RRAM.clear_VRef" href="#RRAM.clear_VRef">clear_VRef</a></code></li>
<li><code><a title="RRAM.clear_VTGT_BL" href="#RRAM.clear_VTGT_BL">clear_VTGT_BL</a></code></li>
<li><code><a title="RRAM.conf_ADC" href="#RRAM.conf_ADC">conf_ADC</a></code></li>
<li><code><a title="RRAM.conf_MAC" href="#RRAM.conf_MAC">conf_MAC</a></code></li>
<li><code><a title="RRAM.conf_VTGT_BL" href="#RRAM.conf_VTGT_BL">conf_VTGT_BL</a></code></li>
<li><code><a title="RRAM.conf_form" href="#RRAM.conf_form">conf_form</a></code></li>
<li><code><a title="RRAM.conf_read" href="#RRAM.conf_read">conf_read</a></code></li>
<li><code><a title="RRAM.conf_reset" href="#RRAM.conf_reset">conf_reset</a></code></li>
<li><code><a title="RRAM.conf_set" href="#RRAM.conf_set">conf_set</a></code></li>
<li><code><a title="RRAM.decode" href="#RRAM.decode">decode</a></code></li>
<li><code><a title="RRAM.ecc" href="#RRAM.ecc">ecc</a></code></li>
<li><code><a title="RRAM.env_init" href="#RRAM.env_init">env_init</a></code></li>
<li><code><a title="RRAM.env_status" href="#RRAM.env_status">env_status</a></code></li>
<li><code><a title="RRAM.form" href="#RRAM.form">form</a></code></li>
<li><code><a title="RRAM.group" href="#RRAM.group">group</a></code></li>
<li><code><a title="RRAM.id" href="#RRAM.id">id</a></code></li>
<li><code><a title="RRAM.lane" href="#RRAM.lane">lane</a></code></li>
<li><code><a title="RRAM.list_DRef" href="#RRAM.list_DRef">list_DRef</a></code></li>
<li><code><a title="RRAM.list_VRef" href="#RRAM.list_VRef">list_VRef</a></code></li>
<li><code><a title="RRAM.list_VTGT_BL" href="#RRAM.list_VTGT_BL">list_VTGT_BL</a></code></li>
<li><code><a title="RRAM.mac" href="#RRAM.mac">mac</a></code></li>
<li><code><a title="RRAM.mask" href="#RRAM.mask">mask</a></code></li>
<li><code><a title="RRAM.mod_conf" href="#RRAM.mod_conf">mod_conf</a></code></li>
<li><code><a title="RRAM.mod_init" href="#RRAM.mod_init">mod_init</a></code></li>
<li><code><a title="RRAM.mod_status" href="#RRAM.mod_status">mod_status</a></code></li>
<li><code><a title="RRAM.module" href="#RRAM.module">module</a></code></li>
<li><code><a title="RRAM.pg" href="#RRAM.pg">pg</a></code></li>
<li><code><a title="RRAM.read" href="#RRAM.read">read</a></code></li>
<li><code><a title="RRAM.read_byte" href="#RRAM.read_byte">read_byte</a></code></li>
<li><code><a title="RRAM.read_lane" href="#RRAM.read_lane">read_lane</a></code></li>
<li><code><a title="RRAM.reg_status" href="#RRAM.reg_status">reg_status</a></code></li>
<li><code><a title="RRAM.reset" href="#RRAM.reset">reset</a></code></li>
<li><code><a title="RRAM.set" href="#RRAM.set">set</a></code></li>
<li><code><a title="RRAM.set_reset" href="#RRAM.set_reset">set_reset</a></code></li>
<li><code><a title="RRAM.sweep_DRef" href="#RRAM.sweep_DRef">sweep_DRef</a></code></li>
<li><code><a title="RRAM.sweep_VRef" href="#RRAM.sweep_VRef">sweep_VRef</a></code></li>
<li><code><a title="RRAM.switch" href="#RRAM.switch">switch</a></code></li>
<li><code><a title="RRAM.write" href="#RRAM.write">write</a></code></li>
<li><code><a title="RRAM.write_byte" href="#RRAM.write_byte">write_byte</a></code></li>
<li><code><a title="RRAM.write_byte_iter" href="#RRAM.write_byte_iter">write_byte_iter</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>